# ES2022 - ES13

See the [ES2022 standard](https://262.ecma-international.org/13.0/) for full specification of the ECMAScript 13 language.

ES13 includes the following new feature proposals:

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Top-level await](#top-level-await)
- []()

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## ECMAScript 13 Features

### Top-level await

In old behavior, When the async/await feature was first introduced, attempting to use an await outside of an async function resulted in a SyntaxError. Many developers utilized as an alternative IIFE (Immediately Invoked Function Expression) as a way to get access to the feature.

```js
await Promise.resolve(console.log('Hello World'));
// Output: SyntaxError: await is only valid in async function

// Alternative to fix the problem
(async function() {
  await Promise.resolve(console.log('Hello World'));
  // Output: Hello World
}());
```

In new behavior, With top-level await, we don't need to use more life hacks.

```js
await Promise.resolve(console.log('Hello World'));
// â†’ Hello World
```

#### `Use Cases`

```js
// 1. Dynamic dependency pathing

const strings = await import(`/i18n/${navigator.language}`);

// This allows for Modules to use runtime values in order to determine dependencies. 
// This is useful for things like development/production splits, internationalization, environment splits, etc.


// 2. Resource initialization

const connection = await dbConnector();

// This allows Modules to represent resources and also to produce errors in cases where the Module will never be able to be used.


// 3. Dependency fallbacks

let jQuery;
try {
  jQuery = await import('https://cdn-a.com/jQuery');
} catch {
  jQuery = await import('https://cdn-b.com/jQuery');
}
```

